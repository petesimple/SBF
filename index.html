<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
  <title>Snowboard Free</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1020; overflow: hidden; }
    canvas { display:block; width: 100vw; height: 100vh; touch-action: none; }
    .hud {
      position: fixed; left: 12px; top: 10px; right: 12px;
      color: #eaf2ff; font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      text-shadow: 0 2px 8px rgba(0,0,0,.6);
      display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;
      pointer-events:none;
    }
    .hud .left { display:flex; flex-direction:column; gap:6px; }
    .badge {
      display:inline-block; padding: 6px 10px; border-radius: 999px;
      background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
    }
    .toast {
      position: fixed; left: 50%; top: 18%;
      transform: translateX(-50%);
      padding: 10px 14px; border-radius: 14px;
      background: rgba(255,255,255,.10); border: 1px solid rgba(255,255,255,.18);
      color: #fff; font: 16px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      text-shadow: 0 2px 10px rgba(0,0,0,.7);
      pointer-events:none;
      opacity: 0; transition: opacity .18s ease;
      white-space: nowrap;
    }
    .toast.show { opacity: 1; }
    .btn {
      pointer-events:auto;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color:#fff; border-radius: 12px;
      padding: 8px 12px;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }
    .footerTip {
      position: fixed; left: 50%; bottom: 12px; transform: translateX(-50%);
      color: rgba(234,242,255,.92);
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 8px 12px;
      text-shadow: 0 2px 8px rgba(0,0,0,.6);
      pointer-events:none;
      text-align: center;
      max-width: calc(100vw - 24px);
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="left">
      <div class="badge" id="scoreBadge">Score: 0</div>
      <div class="badge" id="comboBadge">Combo: x1</div>
      <div class="badge" id="speedBadge">Speed: 0.0</div>
    </div>
    <button class="btn" id="restartBtn">Restart</button>
  </div>
  <div class="toast" id="toast"></div>
  <div class="footerTip">Drag to steer. You only move downhill when your board points downhill. Hit mogul then swipe up for backflip, down for frontflip.</div>
  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    const ui = {
      score: document.getElementById("scoreBadge"),
      combo: document.getElementById("comboBadge"),
      speed: document.getElementById("speedBadge"),
      toast: document.getElementById("toast"),
      restart: document.getElementById("restartBtn"),
    };

    function fitCanvas() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", fitCanvas);
    fitCanvas();

    const W = () => window.innerWidth;
    const H = () => window.innerHeight;

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function rand(a, b) { return a + Math.random() * (b - a); }
    function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }

    const input = {
      active: false,
      x: W() * 0.5,
      y: H() * 0.7,
      swipeDX: 0,
      swipeDY: 0,
      swipeTime: 0,
      swipeStartX: 0,
      swipeStartY: 0,
      swipeStartT: 0,
      justSwiped: false,
    };

    function showToast(text) {
      ui.toast.textContent = text;
      ui.toast.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => ui.toast.classList.remove("show"), 650);
    }

    function pointerPos(e) {
      if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
      return { x: e.clientX, y: e.clientY };
    }

    function onPointerDown(e) {
      e.preventDefault();
      const p = pointerPos(e);
      input.active = true;
      input.x = p.x; input.y = p.y;
      input.swipeStartX = p.x; input.swipeStartY = p.y;
      input.swipeStartT = performance.now();
      input.justSwiped = false;
    }
    function onPointerMove(e) {
      if (!input.active) return;
      e.preventDefault();
      const p = pointerPos(e);
      input.x = p.x; input.y = p.y;
    }
    function onPointerUp(e) {
      if (!input.active) return;
      e.preventDefault();
      const p = pointerPos(e);
      input.active = false;

      const tNow = performance.now();
      const dt = Math.max(1, tNow - input.swipeStartT);
      input.swipeDX = p.x - input.swipeStartX;
      input.swipeDY = p.y - input.swipeStartY;
      input.swipeTime = dt;
      input.justSwiped = true;
    }

    canvas.addEventListener("touchstart", onPointerDown, { passive: false });
    canvas.addEventListener("touchmove", onPointerMove, { passive: false });
    canvas.addEventListener("touchend", onPointerUp, { passive: false });

    canvas.addEventListener("mousedown", onPointerDown);
    window.addEventListener("mousemove", onPointerMove);
    window.addEventListener("mouseup", onPointerUp);

    const keys = {};
    window.addEventListener("keydown", (e) => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener("keyup", (e) => { keys[e.key.toLowerCase()] = false; });

    const game = {
      running: true,
      time: 0,
      scrollY: 0,
      speed: 220,
      speedMul: 1,
      score: 0,
      combo: 1,
      bestCombo: 1,
      state: "ride",
      crashT: 0,
      trick: { active:false, until:0, mogulId:null, required:null, resolved:false }
    };

    const player = {
      x: W() * 0.5,
      y: H() * 0.70,
      r: 14,
      vx: 0,
      spin: 0,
      spinDir: 0,
      airborne: 0,
      dirX: 0,
      dirY: 1,
      carve: 0,       // smoothed -1..1
      moveFactor: 0,  // 0..1
    };

    let nextId = 1;
    const moguls = [];
    const rocks = [];
    const snowFX = [];

    function reset() {
      game.running = true;
      game.time = 0;
      game.scrollY = 0;
      game.speedMul = 1;
      game.score = 0;
      game.combo = 1;
      game.bestCombo = 1;
      game.state = "ride";
      game.crashT = 0;
      game.trick.active = false;
      game.trick.resolved = false;

      player.x = W() * 0.5;
      player.y = H() * 0.70;
      player.vx = 0;
      player.spin = 0;
      player.spinDir = 0;
      player.airborne = 0;
      player.dirX = 0; player.dirY = 1;
      player.carve = 0;
      player.moveFactor = 0;

      moguls.length = 0;
      rocks.length = 0;
      snowFX.length = 0;
      input.justSwiped = false;

      for (let i = 0; i < 10; i++) spawnMogul(-i * 220 - 200);
      for (let i = 0; i < 6; i++) spawnRock(-i * 380 - 300);

      showToast("Shred time");
    }

    function spawnMogul(worldY) {
      moguls.push({ id: nextId++, x: rand(60, W() - 60), y: worldY, r: rand(18, 26), used:false });
    }
    function spawnRock(worldY) {
      rocks.push({ id: nextId++, x: rand(50, W() - 50), y: worldY, r: rand(14, 22) });
    }
    function addPowder(x, y, n = 10) {
      for (let i = 0; i < n; i++) {
        snowFX.push({
          x: x + rand(-8, 8),
          y: y + rand(-8, 8),
          vx: rand(-40, 40),
          vy: rand(-80, -20),
          life: rand(0.25, 0.45),
          t: 0,
        });
      }
    }

    ui.restart.addEventListener("click", reset);
    reset();

    function worldToScreenY(worldY) { return worldY + game.scrollY; }

    function update(dt) {
      if (!game.running) return;
      game.time += dt;

      let targetX = input.x;
      if (!input.active) {
        targetX = clamp(
          player.x
          + (keys["arrowleft"] ? -240 * dt : 0)
          + (keys["arrowright"] ? 240 * dt : 0),
          25, W() - 25
        );
      }

      const dx = targetX - player.x;
      player.vx = dx * 10;
      player.x += dx * clamp(dt * 8, 0, 1);
      player.x = clamp(player.x, 25, W() - 25);

      game.speedMul = 1 + Math.min(1.2, game.time / 45) * 0.8;

      // direction vector
      let dirX = 0, dirY = 1;
      if (input.active) {
        const vx = (input.x - player.x);
        const vy = (input.y - player.y);
        const len = Math.hypot(vx, vy) || 1;
        dirX = vx / len; dirY = vy / len;
      } else {
        const vx = player.vx;
        const vy = 180;
        const len = Math.hypot(vx, vy) || 1;
        dirX = vx / len; dirY = vy / len;
      }
      player.dirX = dirX;
      player.dirY = dirY;

      // downhill gating
      const downhillAlign = dirY;
      const THRESH = 0.25;
      let moveFactor = 0;
      if (downhillAlign > THRESH) {
        moveFactor = (downhillAlign - THRESH) / (1 - THRESH);
        moveFactor = moveFactor * moveFactor;
      }
      player.moveFactor = moveFactor;

      const scrollSpeed = game.speed * game.speedMul * moveFactor;
      game.scrollY += scrollSpeed * dt;

      // smooth carve signal
      const rawCarve = clamp(dirX / 0.9, -1, 1);
      player.carve += (rawCarve - player.carve) * clamp(dt * 10, 0, 1);

      if (input.justSwiped) {
        handleSwipe(input.swipeDX, input.swipeDY, input.swipeTime);
        input.justSwiped = false;
      }

      const topWorld = -game.scrollY - 120;
      const bottomWorld = -game.scrollY + H() + 260;

      while (moguls.length < 14) spawnMogul(topWorld - rand(120, 260));
      while (rocks.length < 9) spawnRock(topWorld - rand(250, 520));

      for (let i = moguls.length - 1; i >= 0; i--) if (moguls[i].y > bottomWorld + 600) moguls.splice(i, 1);
      for (let i = rocks.length - 1; i >= 0; i--) if (rocks[i].y > bottomWorld + 600) rocks.splice(i, 1);

      if (game.trick.active && performance.now() > game.trick.until && !game.trick.resolved) crash("No swipe");

      if (game.state !== "crash") {
        for (const rock of rocks) {
          const sy = worldToScreenY(rock.y);
          if (sy < -60 || sy > H() + 60) continue;
          const rr = (player.r + rock.r) * 0.95;
          if (dist2(player.x, player.y, rock.x, sy) <= rr * rr) { crash("Rock"); break; }
        }

        if (game.state !== "crash") {
          for (const m of moguls) {
            const sy = worldToScreenY(m.y);
            if (sy < -80 || sy > H() + 80) continue;
            const rr = (player.r + m.r) * 0.95;
            if (!m.used && dist2(player.x, player.y, m.x, sy) <= rr * rr) {
              m.used = true;
              beginTrickWindow(m.id);
              addPowder(player.x, player.y + 8, 12);
              break;
            }
          }
        }
      }

      if (player.airborne > 0) {
        player.airborne = Math.max(0, player.airborne - dt);
        player.spin += player.spinDir * dt * 10.5;
      } else {
        player.spin = 0;
        player.spinDir = 0;
      }

      for (let i = snowFX.length - 1; i >= 0; i--) {
        const p = snowFX[i];
        p.t += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 260 * dt;
        if (p.t >= p.life) snowFX.splice(i, 1);
      }

      if (game.state === "crash") {
        game.crashT += dt;
        if (game.crashT > 1.2) {
          game.running = false;
          showToast("Wipeout - tap Restart");
        }
      }

      ui.score.textContent = `Score: ${Math.floor(game.score)}`;
      ui.combo.textContent = `Combo: x${game.combo}`;
      ui.speed.textContent = `Speed: ${(game.speedMul * moveFactor).toFixed(1)}`;
    }

    function beginTrickWindow(mogulId) {
      game.trick.active = true;
      game.trick.resolved = false;
      game.trick.mogulId = mogulId;
      game.trick.required = Math.random() < 0.5 ? "up" : "down";
      game.trick.until = performance.now() + 450;
      showToast(game.trick.required === "up" ? "Swipe up - backflip" : "Swipe down - frontflip");
    }

    function handleSwipe(dx, dy, dtMs) {
      if (!game.trick.active || game.trick.resolved) return;

      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const dist = Math.hypot(dx, dy);
      if (dist < 40 || dtMs > 500) return;
      if (absY < absX * 1.2) return;

      const dir = dy < 0 ? "up" : "down";
      const needed = game.trick.required;

      if (dir === needed) {
        game.trick.resolved = true;
        game.trick.active = false;

        const base = 100;
        const bonus = (game.combo - 1) * 35;
        game.score += base + bonus;
        game.combo = Math.min(20, game.combo + 1);
        game.bestCombo = Math.max(game.bestCombo, game.combo);

        player.airborne = 0.55;
        player.spinDir = (dir === "up") ? 1 : -1;

        addPowder(player.x, player.y + 10, 18);
        showToast(dir === "up" ? "Backflip" : "Frontflip");
      } else {
        crash("Wrong flip");
      }
    }

    function crash(reason) {
      if (game.state === "crash") return;
      game.state = "crash";
      game.crashT = 0;
      game.trick.active = false;
      game.trick.resolved = true;
      game.combo = 1;

      addPowder(player.x, player.y, 28);

      const msg =
        reason === "Rock" ? "Rocked" :
        reason === "Wrong flip" ? "Wrong flip" :
        reason === "No swipe" ? "No swipe" :
        "Wipeout";
      showToast(msg);
    }

    // Pixel helpers
    function p(x, y, s, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * s, y * s, s, s);
    }

    function drawSnowboarder8bit(crashed) {
      const s = 2.3;
      const hop = (player.airborne > 0) ? -6 : 0;

      const OUT = "rgba(0,0,0,0.55)";
      const HELM = crashed ? "rgba(255,120,150,0.95)" : "rgba(245,245,255,0.95)";
      const FACE = "rgba(245,210,170,0.95)";
      const JACKET = crashed ? "rgba(255,90,130,0.85)" : "rgba(90,200,255,0.9)";
      const PANTS = "rgba(60,90,140,0.95)";
      const GLOVE = "rgba(230,230,240,0.9)";
      const BOARD = "rgba(255,255,255,0.9)";
      const BOARD2 = "rgba(0,0,0,0.30)";

      const carve = player.carve;     // -1..1
      const mv = player.moveFactor;   // 0..1
      const absC = Math.abs(carve);

      // Carve amount: 45..90 when moving, 0 when stopped
      const targetMoving = (Math.PI / 4) + (Math.PI / 4) * absC; // 45..90
      const boardAngleMag = targetMoving * mv;

      // IMPORTANT CHANGE:
      // Invert board yaw so it "follows opposite direction" while stance side stays same.
      const boardYaw = -boardAngleMag * Math.sign(carve || 1);

      // stance shift stays the same side mapping you liked
      const side = -Math.sign(carve || 1); // left drag -> shift right
      const stanceX = side * (2 + 4 * absC) * mv;
      const stanceY = 0.5 * mv;

      ctx.save();
      ctx.imageSmoothingEnabled = false;

      ctx.translate(-8 * s, (-18 * s) + hop);
      ctx.translate(stanceX * s, stanceY * s);

      // shadow
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#000";
      ctx.fillRect(4 * s, 22 * s, 8 * s, 3 * s);
      ctx.restore();

      // board under rider
      ctx.save();
      ctx.translate(8 * s, 20 * s);
      ctx.rotate(boardYaw);
      ctx.translate(-8 * s, -20 * s);

      for (let x = 2; x <= 13; x++) p(x, 20, s, OUT);
      p(3, 19, s, OUT); p(12, 19, s, OUT);
      for (let x = 3; x <= 12; x++) p(x, 20, s, BOARD);
      for (let x = 4; x <= 11; x++) p(x, 21, s, BOARD2);
      p(3, 20, s, "rgba(255,70,90,0.85)");
      p(12, 20, s, "rgba(90,180,255,0.85)");
      ctx.restore();

      // rider
      p(6, 18, s, OUT); p(9, 18, s, OUT);
      p(6, 17, s, PANTS); p(9, 17, s, PANTS);

      p(6, 16, s, PANTS); p(7, 16, s, PANTS); p(8, 16, s, PANTS); p(9, 16, s, PANTS);
      p(7, 15, s, PANTS); p(8, 15, s, PANTS);

      p(6, 13, s, JACKET); p(7, 13, s, JACKET); p(8, 13, s, JACKET); p(9, 13, s, JACKET);
      p(6, 14, s, JACKET); p(7, 14, s, JACKET); p(8, 14, s, JACKET); p(9, 14, s, JACKET);
      p(7, 12, s, JACKET); p(8, 12, s, JACKET);

      p(5, 13, s, JACKET); p(10, 13, s, JACKET);
      p(4, 14, s, JACKET); p(11, 14, s, JACKET);
      p(4, 15, s, GLOVE);  p(11, 15, s, GLOVE);

      p(7, 10, s, HELM); p(8, 10, s, HELM);
      p(6, 11, s, HELM); p(7, 11, s, HELM); p(8, 11, s, HELM); p(9, 11, s, HELM);
      p(7, 11, s, "rgba(0,0,0,0.55)");
      p(8, 11, s, "rgba(0,0,0,0.55)");
      p(7, 12, s, FACE);

      ctx.restore();
    }

    function draw() {
      ctx.imageSmoothingEnabled = false;

      ctx.fillStyle = "#08122b";
      ctx.fillRect(0, 0, W(), H());

      // snow bands
      ctx.save();
      ctx.globalAlpha = 0.9;
      for (let i = 0; i < 8; i++) {
        const y = (i / 8) * H();
        ctx.fillStyle = i % 2 === 0 ? "rgba(255,255,255,0.05)" : "rgba(255,255,255,0.025)";
        ctx.fillRect(0, y, W(), H() / 8);
      }
      ctx.restore();

      // slope edges
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(18, 0); ctx.lineTo(18, H());
      ctx.moveTo(W() - 18, 0); ctx.lineTo(W() - 18, H());
      ctx.stroke();

      // rocks
      for (const rock of rocks) {
        const sy = worldToScreenY(rock.y);
        if (sy < -80 || sy > H() + 80) continue;
        ctx.save();
        ctx.translate(rock.x, sy);
        ctx.fillStyle = "rgba(20,25,35,0.9)";
        ctx.beginPath();
        ctx.arc(0, 0, rock.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      // moguls
      for (const m of moguls) {
        const sy = worldToScreenY(m.y);
        if (sy < -100 || sy > H() + 100) continue;
        ctx.save();
        ctx.translate(m.x, sy);
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.beginPath();
        ctx.arc(0, 0, m.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.beginPath();
        ctx.arc(-m.r * 0.25, -m.r * 0.25, m.r * 0.55, 0, Math.PI * 2);
        ctx.fill();
        if (m.used) {
          ctx.fillStyle = "rgba(0,0,0,0.12)";
          ctx.beginPath();
          ctx.arc(0, 0, m.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      // powder
      for (const fx of snowFX) {
        const a = 1 - (fx.t / fx.life);
        ctx.fillStyle = `rgba(255,255,255,${0.7 * a})`;
        ctx.fillRect(fx.x, fx.y, 2, 2);
      }

      // player
      ctx.save();
      ctx.translate(player.x, player.y);

      const aim = Math.atan2(player.dirY, player.dirX);

      // IMPORTANT CHANGE:
      // Flip the whole rider 180 degrees so they face uphill visually.
      const baseRot = (aim - Math.PI / 2) + Math.PI;

      const rot = baseRot + player.spin * 0.35;
      ctx.rotate(rot);

      const crashed = game.state === "crash";

      if (game.trick.active && !crashed) {
        const tLeft = Math.max(0, (game.trick.until - performance.now()) / 450);
        ctx.strokeStyle = game.trick.required === "up" ? "rgba(140,255,170,0.9)" : "rgba(255,200,120,0.9)";
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.25 + 0.55 * tLeft;
        ctx.beginPath();
        ctx.arc(0, 0, player.r + 12, -Math.PI/2, -Math.PI/2 + Math.PI*2*tLeft);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      drawSnowboarder8bit(crashed);
      ctx.restore();

      if (!game.running) {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.45)";
        ctx.fillRect(0, 0, W(), H());
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.font = "700 30px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.fillText("Snowboard Free", W() * 0.5, H() * 0.40);
        ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(`Score: ${Math.floor(game.score)}   Best combo: x${game.bestCombo}`, W() * 0.5, H() * 0.46);
        ctx.fillText("Press Restart to shred again", W() * 0.5, H() * 0.52);
        ctx.restore();
      }
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
