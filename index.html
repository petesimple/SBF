<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,maximum-scale=1,user-scalable=no" />
  <title>Snowboard Free</title>
  <style>
    html, body { height: 100%; margin: 0; background: #ffffff; overflow: hidden; }
    canvas { display:block; width: 100vw; height: 100vh; touch-action: none; }

    .hud{
      position: fixed; left: 12px; top: 10px; right: 12px;
      color:#1b2433; font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      text-shadow: 0 1px 0 rgba(255,255,255,.9);
      display:flex; justify-content:space-between; gap: 10px;
      pointer-events:none;
    }
    .hud .left{ display:flex; flex-direction:column; gap:6px; }
    .badge{
      display:inline-block; padding: 6px 10px; border-radius: 999px;
      background: rgba(255,255,255,.75); border: 1px solid rgba(0,0,0,.08);
      backdrop-filter: blur(6px);
    }
    .toast{
      position: fixed; left: 50%; top: 16%; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 14px;
      background: rgba(0,0,0,.08); border: 1px solid rgba(0,0,0,.10);
      color:#111; font: 16px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      pointer-events:none;
      opacity: 0; transition: opacity .18s ease;
      white-space: nowrap;
    }
    .toast.show{ opacity: 1; }
    .btn{
      pointer-events:auto;
      border: 1px solid rgba(0,0,0,.10);
      background: rgba(255,255,255,.85);
      color:#111; border-radius: 12px;
      padding: 8px 12px;
      font: 14px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      cursor: pointer;
    }
    .btn:active{ transform: translateY(1px); }
    .footerTip{
      position: fixed; left: 50%; bottom: 12px; transform: translateX(-50%);
      color: rgba(10,20,35,.92);
      font: 13px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: rgba(255,255,255,.80);
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 999px;
      padding: 8px 12px;
      pointer-events:none;
      text-align:center;
      max-width: calc(100vw - 24px);
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="left">
      <div class="badge" id="scoreBadge">Score: 0</div>
      <div class="badge" id="comboBadge">Combo: x1</div>
      <div class="badge" id="speedBadge">Speed: 0.0</div>
      <div class="badge" id="camBadge">X: 0</div>
    </div>
    <button class="btn" id="restartBtn">Restart</button>
  </div>
  <div class="toast" id="toast"></div>
  <div class="footerTip">Moguls and halfpipes launch you. Tricks are optional. You only crash on a bad landing (not pointing downhill).</div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const ui = {
    score: document.getElementById("scoreBadge"),
    combo: document.getElementById("comboBadge"),
    speed: document.getElementById("speedBadge"),
    cam: document.getElementById("camBadge"),
    toast: document.getElementById("toast"),
    restart: document.getElementById("restartBtn"),
  };

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(W() * dpr);
    canvas.height = Math.floor(H() * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener("resize", fitCanvas);
  fitCanvas();

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(a, b) { return a + Math.random() * (b - a); }
  function dist2(ax, ay, bx, by) { const dx = ax - bx, dy = ay - by; return dx*dx + dy*dy; }

  function showToast(text) {
    ui.toast.textContent = text;
    ui.toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => ui.toast.classList.remove("show"), 650);
  }

  // Input
  const input = {
    active: false,
    x: W() * 0.5,
    y: H() * 0.7,
    swipeStartX: 0,
    swipeStartY: 0,
    swipeStartT: 0,
    swipeDX: 0,
    swipeDY: 0,
    swipeTime: 0,
    justSwiped: false,
  };

  function pointerPos(e) {
    if (e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    if (e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  function onPointerDown(e) {
    e.preventDefault();
    const p = pointerPos(e);
    input.active = true;
    input.x = p.x; input.y = p.y;
    input.swipeStartX = p.x; input.swipeStartY = p.y;
    input.swipeStartT = performance.now();
    input.justSwiped = false;
  }
  function onPointerMove(e) {
    if (!input.active) return;
    e.preventDefault();
    const p = pointerPos(e);
    input.x = p.x; input.y = p.y;
  }
  function onPointerUp(e) {
    if (!input.active) return;
    e.preventDefault();
    const p = pointerPos(e);
    input.active = false;

    const tNow = performance.now();
    const dt = Math.max(1, tNow - input.swipeStartT);
    input.swipeDX = p.x - input.swipeStartX;
    input.swipeDY = p.y - input.swipeStartY;
    input.swipeTime = dt;
    input.justSwiped = true;
  }

  canvas.addEventListener("touchstart", onPointerDown, { passive: false });
  canvas.addEventListener("touchmove", onPointerMove, { passive: false });
  canvas.addEventListener("touchend", onPointerUp, { passive: false });
  canvas.addEventListener("mousedown", onPointerDown);
  window.addEventListener("mousemove", onPointerMove);
  window.addEventListener("mouseup", onPointerUp);

  const keys = {};
  window.addEventListener("keydown", (e) => { keys[e.key.toLowerCase()] = true; });
  window.addEventListener("keyup", (e) => { keys[e.key.toLowerCase()] = false; });

  // Camera
  const camera = { x: 0, y: 0, follow: 0.12 };

  // Tuning
  const DOWNHILL_THRESH_MOVE = 0.25;
  const DOWNHILL_THRESH_LAND = 0.18;
  const AIR_SPEED_BOOST = 1.45;
  const AIR_FORCE_MOVE = 0.90;

  const game = {
    running: true,
    time: 0,
    speed: 220,
    speedMul: 1,
    score: 0,
    combo: 1,
    bestCombo: 1,
    state: "ride",
    crashT: 0,

    grind: { active:false, until:0, railId:null, t:0 },
    trick: { active:false, done:false, type:null },
  };

  const player = {
    wx: 0,
    wy: H() * 0.70,
    r: 14,

    vx: 0,
    spin: 0,
    spinDir: 0,
    airborne: 0,

    dirX: 0,
    dirY: 1,
    carve: 0,
    moveFactor: 0,

    // visual bank angle used by the sprite
    visualYaw: 0,
  };

  // World objects
  let nextId = 1;
  const moguls = [];
  const rocks = [];
  const trees = [];
  const rails = [];
  const halfpipes = [];
  const snowFX = [];

  // World to screen
  function sx(worldX) { return worldX - camera.x + W() * 0.5; }
  function sy(worldY) { return worldY + camera.y; }

  function spawnMogul(worldY) {
    moguls.push({ id: nextId++, x: camera.x + rand(-W()*0.55, W()*0.55), y: worldY, r: rand(18, 26), used:false });
  }
  function spawnRock(worldY) {
    rocks.push({ id: nextId++, x: camera.x + rand(-W()*0.55, W()*0.55), y: worldY, r: rand(14, 22) });
  }
  function spawnTree(worldY) {
    trees.push({ id: nextId++, x: camera.x + rand(-W()*0.55, W()*0.55), y: worldY, r: rand(16, 22) });
  }
  function spawnRail(worldY) {
    const len = rand(120, 200);
    const angle = rand(-0.25, 0.25);
    rails.push({ id: nextId++, x: camera.x + rand(-W()*0.45, W()*0.45), y: worldY, len, angle, usedUntil: 0 });
  }
  function spawnHalfpipe(worldY) {
    const w = rand(170, 260);
    const h = rand(60, 95);
    // lips (various)
    const lipA = rand(0.6, 1.25);
    const lipB = rand(0.6, 1.25);
    halfpipes.push({
      id: nextId++,
      x: camera.x + rand(-W()*0.40, W()*0.40),
      y: worldY,
      w, h,
      lipA, lipB,
      usedUntil: 0
    });
  }

  function addPowder(screenX, screenY, n = 10) {
    for (let i = 0; i < n; i++) {
      snowFX.push({
        x: screenX + rand(-8, 8),
        y: screenY + rand(-8, 8),
        vx: rand(-40, 40),
        vy: rand(-80, -20),
        life: rand(0.25, 0.45),
        t: 0,
      });
    }
  }

  function distPointSeg(px, py, x1, y1, x2, y2) {
    const vx = x2 - x1, vy = y2 - y1;
    const wx = px - x1, wy = py - y1;
    const c1 = vx * wx + vy * wy;
    if (c1 <= 0) return Math.hypot(px - x1, py - y1);
    const c2 = vx * vx + vy * vy;
    if (c2 <= c1) return Math.hypot(px - x2, py - y2);
    const t = c1 / c2;
    const bx = x1 + t * vx, by = y1 + t * vy;
    return Math.hypot(px - bx, py - by);
  }

  function crash(reason) {
    if (game.state === "crash") return;
    game.state = "crash";
    game.crashT = 0;
    game.grind.active = false;
    game.trick.active = false;
    game.trick.done = false;
    game.trick.type = null;
    game.combo = 1;

    addPowder(W()*0.5, player.wy, 28);
    showToast(reason || "Wipeout");
  }

  function launch(kind) {
    player.airborne = Math.max(player.airborne, kind === "halfpipe" ? 0.90 : 0.70);
    game.trick.active = true;
    game.trick.done = false;
    game.trick.type = null;
    game.grind.active = false;

    addPowder(W()*0.5, player.wy + 10, 18);
    showToast(kind === "halfpipe" ? "Air - halfpipe" : "Air - mogul");
  }

  function handleSwipe(dx, dy, dtMs) {
    if (!game.trick.active || game.trick.done || player.airborne <= 0.01) return;

    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const dist = Math.hypot(dx, dy);
    if (dist < 40 || dtMs > 500) return;
    if (absY < absX * 1.2) return;

    const dir = dy < 0 ? "up" : "down";
    game.trick.done = true;
    game.trick.type = (dir === "up") ? "backflip" : "frontflip";

    const base = (dir === "up") ? 110 : 90;
    const bonus = (game.combo - 1) * 30;
    game.score += base + bonus;
    game.combo = Math.min(20, game.combo + 1);
    game.bestCombo = Math.max(game.bestCombo, game.combo);

    player.spinDir = (dir === "up") ? 1 : -1;
    showToast(dir === "up" ? "Backflip" : "Frontflip");
  }

  function startGrind(rail) {
    game.grind.active = true;
    game.grind.railId = rail.id;
    game.grind.until = performance.now() + 700;
    game.grind.t = 0;
    rail.usedUntil = performance.now() + 1200;
    showToast("Grind");
  }

  function reset() {
    game.running = true;
    game.time = 0;

    camera.x = 0;
    camera.y = 0;

    game.speedMul = 1;
    game.score = 0;
    game.combo = 1;
    game.bestCombo = 1;
    game.state = "ride";
    game.crashT = 0;

    game.grind.active = false;
    game.trick.active = false;
    game.trick.done = false;
    game.trick.type = null;

    player.wx = 0;
    player.wy = H() * 0.70;
    player.vx = 0;
    player.spin = 0;
    player.spinDir = 0;
    player.airborne = 0;
    player.dirX = 0;
    player.dirY = 1;
    player.carve = 0;
    player.moveFactor = 0;
    player.visualYaw = 0;

    moguls.length = 0;
    rocks.length = 0;
    trees.length = 0;
    rails.length = 0;
    halfpipes.length = 0;
    snowFX.length = 0;

    for (let i = 0; i < 10; i++) spawnMogul(-i * 240 - 200);
    for (let i = 0; i < 4; i++) spawnRock(-i * 520 - 450);
    for (let i = 0; i < 10; i++) spawnTree(-i * 240 - 250);
    for (let i = 0; i < 6; i++) spawnRail(-i * 520 - 350);
    for (let i = 0; i < 5; i++) spawnHalfpipe(-i * 680 - 600);

    showToast("Shred mode");
  }

  ui.restart.addEventListener("click", reset);
  reset();

  function update(dt) {
    if (!game.running) return;
    game.time += dt;

    // Lateral intent
    let targetScreenX = input.x;
    if (!input.active) {
      targetScreenX = (W() * 0.5)
        + (keys["arrowleft"] ? -220 : 0)
        + (keys["arrowright"] ? 220 : 0);
    }
    const center = W() * 0.5;
    const intent = clamp((targetScreenX - center) / (W() * 0.35), -1, 1);

    // World lateral movement
    const lateralSpeed = 320;
    player.vx += (intent * lateralSpeed - player.vx) * clamp(dt * 10, 0, 1);
    player.wx += player.vx * dt;

    // Direction for downhill gating
    let dirX = intent, dirY = 1;
    if (input.active) {
      const dy = input.y - player.wy; // finger below = positive
      dirY = clamp(dy / 220, -1, 1);
      const len = Math.hypot(dirX, dirY) || 1;
      dirX /= len; dirY /= len;
    } else {
      const len = Math.hypot(dirX, 1) || 1;
      dirX /= len; dirY = 1 / len;
    }
    player.dirX = dirX;
    player.dirY = dirY;

    game.speedMul = 1 + Math.min(1.2, game.time / 45) * 0.8;

    // Downhill movement factor
    const downhillAlign = player.dirY;
    let moveFactor = 0;
    if (downhillAlign > DOWNHILL_THRESH_MOVE) {
      moveFactor = (downhillAlign - DOWNHILL_THRESH_MOVE) / (1 - DOWNHILL_THRESH_MOVE);
      moveFactor = moveFactor * moveFactor;
    }

    const airborneNow = player.airborne > 0.01;
    if (airborneNow) moveFactor = Math.max(moveFactor, AIR_FORCE_MOVE);
    if (game.grind.active) moveFactor = Math.max(moveFactor, 0.85);

    player.moveFactor = moveFactor;

    const airBoost = airborneNow ? AIR_SPEED_BOOST : 1.0;
    const scrollSpeed = game.speed * game.speedMul * moveFactor * airBoost;
    camera.y += scrollSpeed * dt;

    // Camera follow
    camera.x += (player.wx - camera.x) * clamp(camera.follow, 0, 1);

    // Carve smoothing
    const rawCarve = clamp(player.dirX / 0.9, -1, 1);
    player.carve += (rawCarve - player.carve) * clamp(dt * 10, 0, 1);

    // Sprite visual yaw: board + rider bank into carve when moving
    const absC = Math.abs(player.carve);
    const mv = player.moveFactor;
    const targetMoving = (Math.PI / 4) + (Math.PI / 4) * absC; // 45 to 90
    const yawMag = targetMoving * mv;
    player.visualYaw = -yawMag * Math.sign(player.carve || 1); // bank direction

    // Swipes during airtime
    if (input.justSwiped) {
      handleSwipe(input.swipeDX, input.swipeDY, input.swipeTime);
      input.justSwiped = false;
    }

    // Spawn/cull
    const topWorld = -camera.y - 140;
    const bottomWorld = -camera.y + H() + 320;

    while (moguls.length < 14) spawnMogul(topWorld - rand(140, 280));
    while (rocks.length < 7) spawnRock(topWorld - rand(420, 720));
    while (trees.length < 14) spawnTree(topWorld - rand(140, 320));
    while (rails.length < 8) spawnRail(topWorld - rand(420, 820));
    while (halfpipes.length < 6) spawnHalfpipe(topWorld - rand(520, 980));

    function cull(arr) {
      for (let i = arr.length - 1; i >= 0; i--) {
        if (arr[i].y > bottomWorld + 900) arr.splice(i, 1);
      }
    }
    cull(moguls); cull(rocks); cull(trees); cull(rails); cull(halfpipes);

    // Grind scoring
    if (game.grind.active) {
      game.grind.t += dt;
      game.score += 30 * dt * Math.max(1, game.combo * 0.6);
      if (performance.now() > game.grind.until) game.grind.active = false;
    }

    // Collisions/interactions
    if (game.state !== "crash") {
      // Rocks stop you
      for (const rock of rocks) {
        const rx = sx(rock.x);
        const ry = sy(rock.y);
        if (ry < -120 || ry > H() + 120) continue;
        const rr = (player.r + rock.r) * 0.95;
        if (dist2(W()*0.5, player.wy, rx, ry) <= rr * rr) { crash("Rocked"); break; }
      }

      // Trees stop you
      if (game.state !== "crash") {
        for (const t of trees) {
          const tx = sx(t.x);
          const ty = sy(t.y);
          if (ty < -140 || ty > H() + 140) continue;
          const rr = (player.r + t.r) * 0.90;
          if (dist2(W()*0.5, player.wy, tx, ty) <= rr * rr) { crash("Tree'd"); break; }
        }
      }

      // Moguls launch
      if (game.state !== "crash") {
        for (const m of moguls) {
          const mx = sx(m.x);
          const my = sy(m.y);
          if (my < -140 || my > H() + 140) continue;
          const rr = (player.r + m.r) * 0.95;
          if (!m.used && dist2(W()*0.5, player.wy, mx, my) <= rr * rr) {
            m.used = true;
            launch("mogul");
            break;
          }
        }
      }

      // Rails grind (no grind in air)
      if (game.state !== "crash" && !game.grind.active && player.moveFactor > 0.35 && !airborneNow) {
        for (const r of rails) {
          if (performance.now() < r.usedUntil) continue;

          const cx = sx(r.x);
          const cy = sy(r.y);
          if (cy < -200 || cy > H() + 220) continue;

          const a = r.angle;
          const dx = Math.sin(a) * r.len;
          const dy = Math.cos(a) * r.len;
          const x1 = cx - dx * 0.5;
          const y1 = cy - dy * 0.5;
          const x2 = cx + dx * 0.5;
          const y2 = cy + dy * 0.5;

          const d = distPointSeg(W()*0.5, player.wy, x1, y1, x2, y2);
          if (d < 14) {
            startGrind(r);
            addPowder(W()*0.5, player.wy + 10, 14);
            break;
          }
        }
      }

      // Halfpipes launch (rotated 90 degrees longways)
      if (game.state !== "crash") {
        for (const hp of halfpipes) {
          if (performance.now() < hp.usedUntil) continue;

          const hx = sx(hp.x);
          const hy = sy(hp.y);
          if (hy < -240 || hy > H() + 260) continue;

          // collision as ellipse (rotated look, but ellipse handles it fine)
          // since the pipe is "longways", major axis is along screen Y:
          const a = hp.h * 1.05;      // x-radius (narrow)
          const b = hp.w * 0.32;      // y-radius (long)
          const px = (W()*0.5 - hx) / a;
          const py = (player.wy - hy) / b;
          if ((px*px + py*py) <= 1.0) {
            hp.usedUntil = performance.now() + 1400;
            launch("halfpipe");
            break;
          }
        }
      }
    }

    // Airborne + landing check
    const wasAirborne = player.airborne > 0.01;

    if (player.airborne > 0) {
      player.airborne = Math.max(0, player.airborne - dt);
      player.spin += player.spinDir * dt * 10.5;
    } else {
      player.spin = 0;
      player.spinDir = 0;
    }

    const landedNow = wasAirborne && player.airborne <= 0.01;
    if (landedNow && game.state !== "crash") {
      game.trick.active = false;

      if (player.dirY <= DOWNHILL_THRESH_LAND) {
        crash("Bad landing");
      } else {
        showToast(game.trick.done ? "Landed" : "Clean landing");
      }
    }

    // Particles
    for (let i = snowFX.length - 1; i >= 0; i--) {
      const p = snowFX[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 260 * dt;
      if (p.t >= p.life) snowFX.splice(i, 1);
    }

    // Crash handling
    if (game.state === "crash") {
      game.crashT += dt;
      if (game.crashT > 1.2) {
        game.running = false;
        showToast("Wipeout - tap Restart");
      }
    }

    ui.score.textContent = `Score: ${Math.floor(game.score)}`;
    ui.combo.textContent = `Combo: x${game.combo}`;
    ui.speed.textContent = `Speed: ${(game.speedMul * moveFactor * airBoost).toFixed(1)}`;
    ui.cam.textContent = `X: ${Math.round(camera.x)}`;
  }

  // Sprite pixels
  function px(x, y, s, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * s, y * s, s, s);
  }

  // Snowboarder: board + rider bank together now (no weird upright look)
  function drawSnowboarder8bit(crashed) {
    const s = 2.3;
    const hop = (player.airborne > 0) ? -6 : 0;

    const OUT = "rgba(0,0,0,0.55)";
    const HELM = crashed ? "rgba(255,120,150,0.95)" : "rgba(245,245,255,0.95)";
    const FACE = "rgba(245,210,170,0.95)";
    const JACKET = crashed ? "rgba(255,90,130,0.85)" : "rgba(90,200,255,0.9)";
    const PANTS = "rgba(60,90,140,0.95)";
    const GLOVE = "rgba(230,230,240,0.9)";
    const BOARD = "rgba(255,255,255,0.95)";
    const BOARD2 = "rgba(0,0,0,0.22)";

    const carve = player.carve;
    const mv = player.moveFactor;
    const absC = Math.abs(carve);
    const side = -Math.sign(carve || 1);

    // stance shift feels better while banking
    const stanceX = side * (1.5 + 3.0 * absC) * mv;
    const stanceY = 0.5 * mv;

    ctx.save();
    ctx.imageSmoothingEnabled = false;

    ctx.translate(-8 * s, (-18 * s) + hop);
    ctx.translate(stanceX * s, stanceY * s);

    // (Removed the old shadow rect completely - this was your grey square)

    // board (no separate yaw here; entire sprite banks together via outer rotation)
    for (let x = 2; x <= 13; x++) px(x, 20, s, OUT);
    px(3, 19, s, OUT); px(12, 19, s, OUT);

    for (let x = 3; x <= 12; x++) px(x, 20, s, BOARD);
    for (let x = 4; x <= 11; x++) px(x, 21, s, BOARD2);

    // tip highlights
    px(3, 20, s, "rgba(255,70,90,0.85)");
    px(12, 20, s, "rgba(90,180,255,0.85)");

    // rider (same grid as before, but now it banks with the board)
    px(6, 18, s, OUT); px(9, 18, s, OUT);
    px(6, 17, s, PANTS); px(9, 17, s, PANTS);

    px(6, 16, s, PANTS); px(7, 16, s, PANTS); px(8, 16, s, PANTS); px(9, 16, s, PANTS);
    px(7, 15, s, PANTS); px(8, 15, s, PANTS);

    px(6, 13, s, JACKET); px(7, 13, s, JACKET); px(8, 13, s, JACKET); px(9, 13, s, JACKET);
    px(6, 14, s, JACKET); px(7, 14, s, JACKET); px(8, 14, s, JACKET); px(9, 14, s, JACKET);
    px(7, 12, s, JACKET); px(8, 12, s, JACKET);

    px(5, 13, s, JACKET); px(10, 13, s, JACKET);
    px(4, 14, s, JACKET); px(11, 14, s, JACKET);
    px(4, 15, s, GLOVE);  px(11, 15, s, GLOVE);

    px(7, 10, s, HELM); px(8, 10, s, HELM);
    px(6, 11, s, HELM); px(7, 11, s, HELM); px(8, 11, s, HELM); px(9, 11, s, HELM);

    px(7, 11, s, "rgba(0,0,0,0.55)");
    px(8, 11, s, "rgba(0,0,0,0.55)");
    px(7, 12, s, FACE);

    ctx.restore();
  }

  function draw() {
    ctx.imageSmoothingEnabled = false;

    // Snow base
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, W(), H());

    // Subtle slope bands
    for (let i = 0; i < 9; i++) {
      const y = (i / 9) * H();
      ctx.fillStyle = i % 2 === 0 ? "rgba(10,20,40,0.03)" : "rgba(10,20,40,0.015)";
      ctx.fillRect(0, y, W(), H() / 9);
    }

    // Halfpipes (rotated 90 degrees longways + various lips)
    for (const hp of halfpipes) {
      const hx = sx(hp.x);
      const hy = sy(hp.y);
      if (hy < -280 || hy > H() + 280) continue;

      ctx.save();
      ctx.translate(hx, hy);
      ctx.rotate(Math.PI / 2); // flip 90 degrees so it's longways

      // base trench
      ctx.fillStyle = "rgba(10,20,40,0.05)";
      ctx.beginPath();
      ctx.ellipse(0, 0, hp.w * 0.22, hp.h * 0.95, 0, 0, Math.PI * 2);
      ctx.fill();

      // inner shading
      ctx.fillStyle = "rgba(10,20,40,0.035)";
      ctx.beginPath();
      ctx.ellipse(0, 0, hp.w * 0.16, hp.h * 0.78, 0, 0, Math.PI * 2);
      ctx.fill();

      // lips (vary per pipe)
      ctx.strokeStyle = "rgba(10,20,40,0.12)";
      ctx.lineWidth = 3;

      // left lip
      ctx.beginPath();
      ctx.moveTo(-hp.w * 0.22, -hp.h * 0.55);
      ctx.quadraticCurveTo(-hp.w * 0.22 * hp.lipA, -hp.h * 0.90, -hp.w * 0.22, -hp.h * 1.05);
      ctx.stroke();

      // right lip
      ctx.beginPath();
      ctx.moveTo(hp.w * 0.22, -hp.h * 0.55);
      ctx.quadraticCurveTo(hp.w * 0.22 * hp.lipB, -hp.h * 0.90, hp.w * 0.22, -hp.h * 1.05);
      ctx.stroke();

      ctx.restore();
    }

    // Rails
    for (const r of rails) {
      const cx = sx(r.x);
      const cy = sy(r.y);
      const a = r.angle;
      const dx = Math.sin(a) * r.len;
      const dy = Math.cos(a) * r.len;
      const x1 = cx - dx * 0.5;
      const y1 = cy - dy * 0.5;
      const x2 = cx + dx * 0.5;
      const y2 = cy + dy * 0.5;

      if (Math.min(y1, y2) > H() + 140 || Math.max(y1, y2) < -140) continue;

      ctx.save();
      ctx.strokeStyle = "rgba(0,0,0,0.10)";
      ctx.lineWidth = 8;
      ctx.beginPath(); ctx.moveTo(x1, y1 + 2); ctx.lineTo(x2, y2 + 2); ctx.stroke();

      ctx.strokeStyle = "rgba(20,30,45,0.75)";
      ctx.lineWidth = 6;
      ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();

      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(x1, y1 - 1); ctx.lineTo(x2, y2 - 1); ctx.stroke();
      ctx.restore();
    }

    // Rocks
    for (const rock of rocks) {
      const rx = sx(rock.x);
      const ry = sy(rock.y);
      if (ry < -120 || ry > H() + 120) continue;
      ctx.save();
      ctx.translate(rx, ry);
      ctx.fillStyle = "rgba(30,35,45,0.85)";
      ctx.beginPath(); ctx.arc(0, 0, rock.r, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 2; ctx.stroke();
      ctx.restore();
    }

    // Trees (flipped 180)
    for (const t of trees) {
      const tx = sx(t.x);
      const ty = sy(t.y);
      if (ty < -140 || ty > H() + 140) continue;

      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(Math.PI); // flip 180 as requested

      ctx.fillStyle = "rgba(10,20,40,0.04)";
      ctx.beginPath();
      ctx.ellipse(0, 10, t.r * 1.15, t.r * 0.75, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "rgba(120,80,45,0.95)";
      ctx.fillRect(-6, 2, 12, 14);

      ctx.fillStyle = "rgba(30,140,70,0.95)";
      ctx.beginPath();
      ctx.moveTo(0, -26);
      ctx.lineTo(-22, 4);
      ctx.lineTo(22, 4);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(20,110,55,0.95)";
      ctx.beginPath();
      ctx.moveTo(0, -14);
      ctx.lineTo(-18, 10);
      ctx.lineTo(18, 10);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.beginPath();
      ctx.moveTo(0, -28);
      ctx.lineTo(-7, -18);
      ctx.lineTo(7, -18);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    // Moguls
    for (const m of moguls) {
      const mx = sx(m.x);
      const my = sy(m.y);
      if (my < -140 || my > H() + 140) continue;
      ctx.save();
      ctx.translate(mx, my);
      ctx.fillStyle = "rgba(10,20,40,0.05)";
      ctx.beginPath(); ctx.arc(0, 0, m.r, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = "rgba(10,20,40,0.04)";
      ctx.beginPath(); ctx.arc(-m.r * 0.25, -m.r * 0.25, m.r * 0.55, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }

    // Powder
    for (const fx of snowFX) {
      const a = 1 - (fx.t / fx.life);
      ctx.fillStyle = `rgba(255,255,255,${0.9 * a})`;
      ctx.fillRect(fx.x, fx.y, 2, 2);
    }

    // Player at screen center X
    ctx.save();
    ctx.translate(W()*0.5, player.wy);

    // Rotate whole sprite into the carve (this is the fix for "upright rider")
    // Keep uphill vibe by blending: when stopped, less yaw; when moving, more yaw.
    const bank = player.visualYaw;
    const spin = player.spin * 0.35;
    ctx.rotate(bank + spin);

    // Air ring
    if (player.airborne > 0.01 && game.state !== "crash") {
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "rgba(0,0,0,0.20)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(0, 0, player.r + 12, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    drawSnowboarder8bit(game.state === "crash");
    ctx.restore();

    // Game over
    if (!game.running) {
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.fillRect(0, 0, W(), H());
      ctx.fillStyle = "rgba(10,20,35,0.95)";
      ctx.font = "800 30px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.fillText("Snowboard Free", W()*0.5, H()*0.40);
      ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(`Score: ${Math.floor(game.score)}   Best combo: x${game.bestCombo}`, W()*0.5, H()*0.46);
      ctx.fillText("Press Restart to shred again", W()*0.5, H()*0.52);
      ctx.restore();
    }
  }

  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
